---
title: "Computing for the Social Sciences: Lecture 6"
subtitle: "Topics: Deep Dive into dplyr & Factors in R"
author: "Sabrina Nardin, Fall 2025"
format:
  revealjs:
    theme: simple
    slide-number: true
    incremental: false
    css: ../style/styles.css
    code-overflow: wrap
    highlight-style: github
    ratio: 16:9
    chalkboard: true
    toc: false
    center: true
---

# Agenda {.center}

::: {.agenda-list}
1. Review and expand our knowledge of dplyr for data manipulation
2. Define and use Factors in R 
:::

<span style="font-size: 0.8em; color: #666;">
*Slides last updated on **October 15, 2025**. Slides authored by Sabrina Nardin. AI used to polish slides style and fix typos.*
</span>

<!--
<span style="font-size: 0.8em; color: #666;">
*Slides last updated on **`r format(Sys.Date(), '%B %d, %Y')`**. Slides authored by Sabrina Nardin. AI used to polish slides style and fix typos.*
</span>
-->

<!-- 
Changes needed: Add more formal factor explanation (check Fall24 slides) as I cut it for CSP Sum25. Add more dplyr examples here. Do live coding but make it interactive compared to Fall24. Take the in-class exercise from lecture 4: use task 2 to teach factors and task 4 for more dplyr (For Fall25: adjust CSP Sum25 lecture 4 slides accordingly and move that part here). 
-->


# 1. Deep dive into dplyr

---

## Most Important dplyr Functions: Definitions

| `function()`   | What it does                                                       |
|----------------|---------------------------------------------------------------------|
| `select()`     | Chooses specific columns                                           |
| `rename()`     | Renames columns                                                    |
| `relocate()`   | Reorders columns                                                   |
| `filter()`     | Selects rows based on values on columns                            |
| `arrange()`    | Reorders rows based on values in specified columns                 |
| `mutate()`     | Adds new columns or modifies existing ones                         |
| `distinct()`   | Returns unique rows based on columns                               |
| `group_by()`   | Groups the data by one or more variables for grouped operations    |
| `count()`      | Counts observations by group                                       |
| `summarize()`  | Reduces each group to a single row using summary statistics (e.g., mean, sum, n) |
| `across()`     | Applies the same operation to multiple columns at once             |


---

## Most important dplyr Functions: Tips to Rememeber and Examples

| Focus | Concept | Function |
|:----|:--|:-------------------------------------------------------------|
| **Columns** | Structure | `select()` chooses specific columns — `select(penguins, species, island)`<br>`rename()` renames columns — `rename(penguins, flip_mm = flipper_length_mm)`<br>`relocate()` reorders columns — `relocate(penguins, island, .before = species)` |
| **Rows** | Filtering & sorting | `filter()` selects rows by values — `filter(penguins, species == "Adelie")`<br>`arrange()` orders rows by column values — `arrange(penguins, desc(body_mass_g))` |
| **Values** | Transformation | `mutate()` adds or changes columns — `mutate(penguins, flip_cm = flipper_length_mm / 10)`<br>`distinct()` keeps unique rows — `distinct(penguins, species, island)` |
| **Groups** | Aggregation | `group_by()` defines groups — `group_by(penguins, species)`<br>`count()` counts rows per group — `count(penguins, island)` <br> `summarize()` creates summaries per group — `summarize(penguins, avg_flip = mean(flipper_length_mm, na.rm = TRUE))` |
| **Across columns** | Automation | `across()` applies an operation to multiple columns — `summarize(across(ends_with("_mm"), mean, na.rm = TRUE))` |

<br>

<div style="font-size:0.8em; color:#666; text-align:center; margin-top:0.5em;">Data flows top → bottom just like in a pipeline: penguins |> select() |> filter() |> group_by() |> summarize()</div>

---

## Penguins data

Load libraries and data:
```r
library(tidyverse)
library(palmerpenguins)
data(penguins)
```

Explore data (pick one of these):
```r
rbind(head(penguins, 5), tail(penguins, 5))
glimpse(penguins)
str(penguins)
summary(penguins)
```

---

## select() extracts variables, operates on columns

```r
# select two specific variables using their names
select(penguins, species, body_mass_g)

# select all variables except two using the minus sign
select(penguins, -year, -island)

# select a range of contiguous/adjacent variables
select(penguins, species:bill_length_mm)

# select all variables except a range of contiguous ones
select(penguins, -(species:island))

# select all variables that start with
select(penguins, starts_with("bill"))

# select all variables that end with
select(penguins, ends_with("mm"))
```
---

## filter() extract observations, operates on rows

```r
# check variable values
levels(penguins$species) 
unique(penguins$species)
count(penguins, species)
penguins |> count(species)

# filter by island and species
filter(penguins, island == "Biscoe", species == "Gentoo")
filter(penguins, (island == "Biscoe" & species == "Gentoo"))

# filter by multiple conditions
filter(penguins, species %in% c("Adelie", "Gentoo"), island != "Biscoe")

```
---

## select() plus filter()

```r
penguins |> 
  select(species, sex, year, island) |> 
  filter(island == "Torgersen")
```
---

## arrange() changes order of observations

```r
penguins |> arrange(desc(bill_length_mm))

penguins |>
  select(species, contains("bill")) |>
  filter(!species == "Adelie") |>
  arrange(desc(bill_length_mm)) 

penguins |>
  select(species, contains("bill")) |>
  filter(!species == "Adelie") |> 
  arrange(desc(species), bill_length_mm)
```

---

## relocate() changes order of variable 

```r
penguins |> relocate(year, sex)

penguins |> relocate(year, .after = island)
```

---

## mutate() modify or create new columns

```r
penguins |> mutate(bill_ratio = bill_length_mm / bill_depth_mm)
```

Note: it does not reduce the dimensions of the original data https://dplyr.tidyverse.org/reference/mutate.html

---

## summarize() summary of data

```r
penguins |> 
  summarize(body_mass_mean = mean(body_mass_g, na.rm = TRUE),
            body_mass_sd = sd(body_mass_g, na.rm = TRUE),
            n = n())  # n = nrow(penguins)

penguins | 
  filter(species == "Gentoo") |> 
  summarize(body_mass_mean = mean(body_mass_g, na.rm = TRUE),
            body_mass_sd = sd(body_mass_g, na.rm = TRUE),
            n = n())
```

Note: collapses the original data to a smaller number of rows, you can use summarize to create all sort of summary statistics https://dplyr.tidyverse.org/reference/summarise.html

---

## group_by() aggregates data for next function

```r
# group by alone? not that useful
penguins |> 
  group_by(island, sex)

# group by and count
penguins |> 
  group_by(island, sex) |> 
  count()

# group by and calculate mean body mass
penguins |> 
  group_by(island, sex) |>
  summarize(body_mass_mean = mean(body_mass_g, na.rm = TRUE))
```

---

## count() counts tot obs. by group

```r
# total penguins by sex without count
penguins |> 
  group_by(sex) |> 
  summarize(total = n())

# with count
penguins |>
  count(sex)
```

---

## distinct() returns unique rows based on given columns

```r
# not too handy alone
penguins |>
  distinct()

# better with specific columns
penguins |>
  distinct(species, island)

# keep all columns in the resulting data frame
penguins |>
  distinct(species, island, .keep_all = TRUE)
```

Note: gives back a dataframe with only unique combinations of those columns https://dplyr.tidyverse.org/reference/distinct.html 

---

## across()

Examples with and without `across()` with numerical variables:

```r
# mean for a bunch of variables without across
penguins |>
  summarize(
    mean_bill_length_mm = mean(bill_length_mm, na.rm = TRUE),
    mean_bill_depth_mm = mean(bill_depth_mm, na.rm = TRUE),
    mean_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE),
    mean_body_mass_g = mean(body_mass_g, na.rm = TRUE)
  )

# same operation with across
penguins |>
  summarize(
    across(
      c(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g), 
      ~ mean(.x, na.rm = TRUE)  # function(x) mean(x, na.rm = TRUE)
    ))
```

---

## across()

Examples with and without `across()` with categorical variables:

```r
# number of distinct entries for columns without across
penguins |>
  summarise(distinct_species = n_distinct(species),
            distinct_island = n_distinct(island),
            distinct_year = n_distinct(year))

# number of distinct entries for columns with across
penguins |>
  summarise(across(c(species, island, year), 
                   n_distinct))

# the opposite
penguins |>
  summarise(across(-c(species, island, year), 
                   n_distinct))

# everything
penguins |>
  summarise(across(everything(), 
                   n_distinct))
```


# 2. Factors in R {.slide .center .middle}


## What are Factors in R?

**A factor is a specific data structure in R.**

To understand factors, and why we use them, we need to start from categorical data or variables: variables with a fixed set of possible values. For example, the variable `species` in the `penguins` data can only take one of three values ("Adelie", "Chinstrap", or "Gentoo").

---

## What are Factors in R?

:::{.callout-note title="R Data Structures to Store Categorical Data"}

- **Character vector (default):** Data type for storing categorical data as plain strings (e.g., variable `months` with "Jan", "Feb", "Mar", etc.). Values have no built-in order or grouping.

- **Numeric vector (occasionally):** Sometimes these are used to store categorical data as numbers (e.g., variable `months` with 1, 2, 3), but lacks category labels or order.

- **Factor (preferred when order matters):** Data type for storing categorical data with defined levels. Values can be ordered according to the researcher needs. 

:::

---

## Real-world examples of categorical data

You often need factors in R. Why? They let you sort categorical variables in **your desired order** whether that order reflects a natural sequence or you define it for analytic purposes. Examples:

- Months of the year (January → December)
- Likert scales (Strongly Agree → Strongly Disagree)
- Educational attainment levels (High School → Graduate)
- Political parties
- Race/ethnicity categories
- Institution type
- Movies categories 
- Etc.

---

## Why use Factors?

Let's define a character vector with four months and sort it.  
Copy and paste this code in R and run it. What do you notice?   

```r
# Define
x1 <- c("Dec", "Apr", "Jan", "Mar")

# Check
x1
class(x1)

# Sort
sort(x1)
```

---

## Why use Factors?

From the previous example we observe that **by default, R sorts character vectors alphabetically!** 

However, alphabetical order isn’t ideal to sort months. We usually want them sorted in chronological order. To do that in R, we need factors.

::: {.callout}
In the next slides, we learn two cases that you will likely encounter when working with factors:

1. Converting a **Character Vector to a Factor** (most common)
2. Converting a **Numeric Vector to a Factor** (sometimes needed when categories are stored as numbers)
:::

---

## 1. Converting a Character Vector to a Factor

Often categorical data is stored in character vectors. Character vectors sort alphabetically by default. To change the order, convert them to a factor using `factor()` and assign the desired **levels.**

```r
# Character vector with month names
x1 <- c("Dec", "Apr", "Jan", "Mar")
class(x1)

# Define all set of possibile levels in desired order
month_levels <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")

# Convert to factor using those levels
y1 <- factor(x1, levels = month_levels)

# Check
y1
class(y1)
levels(y1)

# Compare sorting
sort(x1)  # Alphabetical
sort(y1)  # Chronological (by factor levels)
```

<!-- 
# SHORTER CODE

# Character vector with month names
x1 <- c("Dec", "Apr", "Jan", "Mar")
class(x1)

# Convert to factor using levels
y1 <- factor(x1, levels = c("Jan", "Mar", "Apr", "Dec"))

# if you pick another order, it will follow that one!
-->

---

## 2. Converting a Numeric Vector to a Factor

Sometimes categorical data is stored as numbers (e.g., months as 1, 2, 12) in numeric vectors. To convert them to a factor with `factor()`, you need to specify **both levels and labels.**

```r
# Numeric vector with values representing months
x2 <- c(12, 4, 1, 3)
class(x2)

# Define all set of possibile numeric values we expect
month_levels <- 1:12

# Define all labels we want to show for each value
month_labels <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec") 

# Convert to factor using levels and labels
y2 <- factor(x2, 
            levels = month_levels,
            labels = month_labels)

# Check
y2
class(y2)
levels(y2)

# Compare sorting
sort(x2)  # Numeric
sort(y2)  # Chronological (by factor levels)
```

<!-- 
**Question:** Why we are defining all possible levels and labels when only four are needed here? It will work either way, but it's good practice to define the full set and order of categories.

# SHORTER CODE

# Define all labels we want to show for each value
month_labels <- c("Jan", "Mar", "Apr", "Dec") 

# Convert to factor using levels and labels
y2 <- factor(x2, 
             levels = x2,
             labels = month_labels)
-->

---

## Levels and Labels in Factors

:::: {.columns}

::: {.column width="50%"}
### Levels  
- Define the set of distinct categories a factor can take  
- Use to tell R the **order** of each category 
- Use **only levels** when your input data is already human readable, as in our first example (e.g., `"Jan"`, `"Feb"`, etc.)
:::

::: {.column width="50%"}
### Labels  
- Define optional names for each distinct category
- Use to tell R **what to display** for each category  
- Use **labels and levels** when your input data uses codes, as in our second example (e.g., `1` to mean `"Jan"`), and you want to display more human readable labels. Labels are matched to levels, not to raw values
:::

::::

---

## Levels and Labels in Factors

:::{.columns}

::: {.column width="50%"}
### When you input is a Character Vector

**Example values**: `"Jan"`, `"May"`, `"Oct"`

- Already human-readable
- (Often) only want to control the order  
- Convert to factor using only **`levels`** to order and label
- Example: `"May"` stays `"May"`
:::

::: {.column width="50%"}
### When you input is a Numeric Vector

**Example values**: `1`, `7`, `12`

- Not already human-readable
- Want to control the order & add readable labels
- Convert to factor using **`levels`** to order & **`labels`** to label
- Example: `1` becomes `"Jan"`,  `2` becomes `"Feb"`, etc.
:::

:::

<!--
## Summary of Levels and Labels in Factors


| **Type**           | **What It Represents**              | **Levels** — Store & Sort By                 | **Labels** — Display Names                    | **Example**                                              |
|--------------------|-------------------------------------|------------------------------------------------|------------------------------------------------|----------------------------------------------------------|
| Character Vector   | Categorical names (`"Jan"`)   | To control order (e.g., Jan, Feb, ..., Dec)   | Not needed — values are already readable       | `factor(x1, levels = month_names)`                      |
| Numeric Vector     | Coded categories (`1`)   | To match internal codes (e.g., 1 = Jan,..., 12 = Dec) | To assign readable labels to codes (e.g., "Jan", ...) | `factor(x2, levels = 1:12, labels = month_names)`       |

-->

---

## Levels and Labels in Factors: Examples

Before you run the code below in R, take a moment to predict the output.
What do you expect each code chunk to return, and why?

```r
# Example 1 with Input as Character Vector
a <- c("Low", "High", "Medium", "Low")
b <- factor(a, levels = c("Low", "Medium", "High"))
b
sort(b)

# Example 2 with Input as Numeric vector
i <- c(1, 3, 2, 1)
j <- factor(i, levels = c(1, 2, 3),
               labels = c("Low", "Medium", "High"))
j
sort(j)
```

<!--
# Note on Example 1

If you write labels rather then levels you get a wrong output!
# you can use both levels and labels also here but not needed
c <- factor(a, levels = c("Low", "Medium", "High"),
               labels = c("L", "M", "H"))
               
- Clear mapping: 1 → "Low", 2 → "Medium", 3 → "High"
- Labels are matched to levels, not to raw values
-->

---

## 💻 Practice: Character Vector → Factor

You are working with a **character vector**. Your goal is to convert it into a factor so, when you sort it, months follow their chronological order rather than alphabetical order.

The code below is not correct. Run it in R, identify the problem, and fix it.

```r
# Define a character vector representing months
m <- c("Dec", "Apr", "Jan", "Mar")
class(m)

# Attempt
mf <- factor(m, 
            levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12),
            labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                       "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
mf

# Compare sorting
sort(m)  
sort(mf)
```

---

## Solution: Character Vector → Factor

The input vector is made of characters ("Jan", "Feb"...) but the levels provided are numbers (1–12). R can’t match them: levels must match the type of your input data.

```r
mf <- factor(m, 
             levels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))
mf
sort(mf)
```

---

## 💻 Practice: Numeric Vector → Factor

You are working with a **numeric vector** representing months as numbers. Your goal is the same: convert it into a factor, so when you sort it, months are in chronological order.

None of the attempts below is correct. Run each in R, explain why each does not work, and write one solution that works.


```r
# Define a numeric vector representing months
x <- c(12, 4, 1, 3, 1)
class(x)

# Attempt 1
y1 <- factor(x, levels = x,
                labels = c("Jan", "Mar", "Apr", "Dec"))
                
# Attempt 2
y2 <- factor(x, levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), 
                labels = c("Jan", "Mar", "Apr", "Dec"))
              
# Attempt 3
y3 <- factor(x, levels = c(1, 2, 3, 4),
                labels = c("Jan", "Mar", "Apr", "Dec"))
```
---

## Solution: Numeric Vector → Factor

- Attempts 1 and 2: mismatch between the number of labels and the levels. R throws an error.

- Attempt 3: R doesn't throw an error, but the code is incorrect because it forces levels 1 to 4, even though the input vector has values like 12. Since 12 isn’t among the defined levels, it becomes `NA`, leading to incorrect matches.

You can fix the code from the previous slide in the following ways:

```r
# Numeric vector representing months
x <- c(12, 4, 1, 3, 1)
class(x)

# Option 1 (reccomended)
month_labels <- c("Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec")
month_levels = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
y1 <- factor(x, levels = month_levels,  
                labels = month_labels)
class(y1)

# Option 2 (works but not reccomended, why?)
y2 <- factor(x, levels = c(1, 3, 4, 12),
                labels = c("Jan", "Mar", "Apr", "Dec"))

```

<!--

Option 1: creates a factor with all 12 months as possible levels, even if only 4 are used. Best option because it preserves the full structure of the variable.

Option 2: only keeps levels that appear in the data. Correct but incomplete, fails if new values (e.g. 5) appear later.

If you don’t specify `levels`, R will use the unique values in the data — so mismatches can lead to warnings or incorrect labeling. 

Tip: to avoid problems, specify both `levels` and `labels` explicitly.
-->

---

## Apply these concpets to a dataframe: scorecard example

In most of your work, you deal with dataframes. Last week we worked with the `scorecard` data to practice `ggplot2`. Now we use the same data to see how we can use factors in a dataframe. 

Load libraries and data:
```r
library(tidyverse)
library(rcis)
data(scorecard)
```

Explore data:
```r
glimpse(scorecard)
```
---

## Example: Plot the total number of schools in the U.S. by school type

This is the same question we did in class (see in-class tutorial, lecture 4).
 
Since `type` is a categorical varialbe, we use bar chart, which takes each category `"Public"`, `"Private nonprofit"`, `"Private for profit"` and automatically applies a frequency count to aggregate the data.

```r
ggplot(scorecard, mapping = aes(x = type)) +
  geom_bar() 
```

<br>

#### Our goal: reorder the bars!

</br>

---

## Method 1: Reorder bars manually with *factor()*

```r
s <- scorecard |>
  mutate(type = factor(type,
                       levels = c("Private, nonprofit", "Public", "Private, for-profit")))

ggplot(s, aes(x = type)) +
  geom_bar()

```
This method gives you full control of the order by manually defining factor levels.

Remember to check the column type (character or numeric) before transforming to factor. Use mutate since we are working on column of a dataframe (and not a standalone vector like in the previous examples). 

---

## Method 2: Reorder the bars using tidyverse *fct_relevel()*

[`fct_relevel()`](https://forcats.tidyverse.org/reference/fct_relevel.html): allows to reorder factor levels by hand; this function behave similarly to `factor()`

```r
scorecard |> 
  mutate(type = fct_relevel(type, 
                           "Private, nonprofit", "Public", "Private, for-profit")) |>
ggplot(mapping = aes(x = type)) +
  geom_bar()

```

Note: you can write code also by "piping" the results of the `dplyr` code into `ggplot2` code, as illustrated here. 

---

## Method 3: Reorder the bars using tidyverse *fct_infreq()*

[`fct_infreq()`](https://forcats.tidyverse.org/reference/fct_inorder.html) sorts bars automatically by how common each category is (most to least frequent)

```r
scorecard |>
  mutate(type = fct_infreq(type)) |>
ggplot(aes(x = type)) +
  geom_bar()
```

---

## The "forcats" Package

:::{.callout-note title="Using factor() or a function from forcats?"}

The function `factor()` is the base R way to create and manage factors. It’s a foundational tool: worth understanding because many R functions depend on it!

Since working with factors is key in R, people developed a specific package called `forcats` (part of the `tidyverse`) provides a set of simpler but powerful functions for working with categorical data.

You can use these, but knowing `factor()` helps you understand what’s happening behind the scenes.
:::

---

## The "forcats" Package

| Function         | What it does                                      | When to use                                      |
|------------------|---------------------------------------------------|--------------------------------------------------|
| `fct_relevel()`  | Manually sets the order of levels                 | When you need full manual control (similar to `factor(..., levels = ...)` in base R) |
| `fct_infreq()`   | Reorders factor levels by frequency (most to least common) | When you want categories ordered by how often they appear |
| `fct_reorder()`  | Reorders levels based on another variable (e.g., a numeric value) | Ideal for ordering bars by a summary statistic in `ggplot2` |


For more functions, see the [forcats documentation](https://forcats.tidyverse.org/)


--- 

## 💻 Challenge Exercise: Plot Tips by Weekday

In this exercise, you learn two things:

- to correctly use `stat = identity` with bar plots

- to control the order of categories in bar plots, using both `factor()` and the `forcats` function called `fct_relevel()`

---

## Create the Data

Copy and run the code below to create this dataset:

```r
library(tidyverse)

df <- tibble(
  week = c("Mon", "Wed", "Fri", "Wed", "Thu", "Sat", "Sat"),
  tip = c(10, 12, 20, 8, 25, 25, 30)
)

df
```

**Our Goal:** Create a bar plot with days of the `week` on the x-axis and the total `tip` amount on the y-axis (e.g., Saturday should display a bar with a height of $55, etc.).

---

## What's Wrong With This Plot?

Try this code. What does the height of each bar represent?

```r
ggplot(df, aes(x = week)) +
  geom_bar()
```

<fragment>

:::{.callout-warning}
Why aren't the bars showing the actual tip amounts?  
- Because by default, `geom_bar()` uses `stat = "count"` to counts row and plot them on the y-axis  
- To plot the actual values (not counts), use `stat = "identity"` with both a x and y

:::

</fragment>

---

## Fix the y-axis on this bar plot

To fix this plot, we need to change the default `stat` from count to identity and manually specify both the `x` and `y` aesthetics. *See the [documentation](https://ggplot2.tidyverse.org/reference/geom_bar.html) or type `?geom_bar` in your R Console.*

```r
ggplot(df, aes(x = week, y = tip)) +
  geom_bar(stat = "identity") +
  labs(title = "Tips by Weekday", x = "Weekday", y = "Tip ($)")
```
This is much better, but we still do not have the bars nicely ordered....

---

## Fix the order of the bars using factor()

We use base R's `factor()` to control the order of weekdays.

Replace the blank with the correct weekday order in the code below:

```r
df |>
  mutate(week = factor(week, levels = _____ )) |>
  ggplot(aes(x = week, y = tip)) +
  geom_bar(stat = "identity") +
  labs(title = "Tips by Weekday", x = "Weekday", y = "Tip ($)")
```

---

## Do the same but using fct_relevel()

Now we make the same plot using [`fct_relevel()`](https://forcats.tidyverse.org/reference/fct_relevel.html)

Replace the correct weekday order in the code below:

```r
df |>
  mutate(week = fct_relevel(week, ______ )) |>
  ggplot(aes(x = week, y = tip)) +
  geom_bar(stat = "identity") +
  labs(title = "Tips by Weekday", x = "Weekday", y = "Tip ($)")
```

<!--

Note: Leave out for CSP, bring back for CSS class. The actual code gives what I want (Sat is 55 etc) so unsure this is actually needed

## Group and Summarize

Now try grouping by weekday and summing the tips before plotting. Use either `factor()` or `fct_relevel()`.

```r
df %>%
  mutate(week = factor(week, days)) %>%   # factor() or fct_relevel()
  group_by(week) %>%
  summarize(total_tip = sum(tip)) %>%
  ggplot(aes(x = week, y = total_tip)) +
  geom_bar(stat = "identity") +
  labs(title = "Total Tips by Weekday", x = "Weekday", y = "Total Tip ($)")
```

Add this on slides: Keep these tricks in mind for the homework assignments, especially HW3 (e.g., how to change a variable into a factor and manually pass labels for your graphs; and how to reorder a variable chronologically (here Mon to Sat) for plotting purposes)

Consider putting this challenge in the practice exercises for today as well

For the dplyr part: add in the Rmd file demo an example of what happens if you calculate the mean of a boolean or logical vectors (T and F), say that T are interpreted as 1 and F are 0 for R; this is useful again for HW3!  
-->

---

## Solutions

```r
# With factor
days <- c("Mon", "Wed", "Thu", "Fri", "Sat")
df |>
  mutate(week = factor(week, levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"))) |>
  ggplot(aes(x = week, y = tip)) +
  geom_bar(stat = "identity") +
  labs(title = "Tips by Weekday", x = "Weekday", y = "Tip ($)")

# With fct_relevel
days <- c("Mon", "Wed", "Thu", "Fri", "Sat")
df |>
  mutate(week = fct_relevel(week, days)) |>
  ggplot(aes(x = week, y = tip)) +
  geom_bar(stat = "identity") +
  labs(title = "Tips by Weekday", x = "Weekday", y = "Tip ($)")
```

:::{.callout}
**Q: Why don’t we use `labels` in `factor()`?** Because the values (`"Mon"`, etc.) are already readable. You don’t need to change them, unless you want different names (e.g., `"Monday"`, etc.).

**Q: Why doesn’t `days` include all 7 days of the week?** We should include all possible levels when using `factor()`. But `fct_relevel()` behave differently and may not add missing levels if those values aren’t present in the input data.
:::

<!--
Note the c() is the standard way of creating a vector 
but fct_relevel() accepts multiple strings directly via ..., so you can skip c() and write directly fct_relevel(week, "Mon", "Wed", "Thu", "Fri", "Sat"_
Both versions are valid

FOR CSS CLASS: add one example with fct_reorder() as it is the most straightforward application
-->

---

## Reflections

:::{.callout-tip}
- What happens when you don’t set the factor order?
- Which method (`factor()` or `fct_relevel()`) do you prefer and why? Check the `forcats` package documentation for more functions, especially `fct_reorder()` which is straightforward to use
- Why is `stat = "identity"` necessary for this kind of plot?
- Always match the number of provided `levels` and `labels` inside `factor()``
:::

Want more practice? Download today's in-class materials for more practice exercises on working with factors!

---

## Recap: What We Learned Today

- What factors are and how to convert character or numeric vectors to factors  
- How to control the order of categories using `levels` and `labels`  
- How to fix common `geom_bar()` plotting issues (e.g., bar heights and order)
- Reviewed and expanded `dplyr` functions for data manipulation

---

## To print these slides as pdf

Click on the icon bottom-right corner \> Tools \> PDF Export Mode \> Print as a Pdf
