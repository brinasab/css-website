---
title: "Computing for the Social Sciences: Lecture 13"
subtitle: "Topics: Control Flow 2 (cont.); Functions 1"
author: "Sabrina Nardin, Fall 2025"
format:
  revealjs:
    theme: simple
    slide-number: true
    incremental: false
    css: ../style/styles.css
    code-overflow: wrap
    highlight-style: github
    ratio: 16:9
    chalkboard: true
    toc: false
    center: true
---


# Agenda {.center}

::: {.agenda-list}
1. Using For Loops with Dataframes 
2. Alternatives to For Loops in R
3. While Loops
4. Introduction to Functions
:::

<span style="font-size: 0.8em; color: #666;">
*Slides last updated on **November 11, 2025**. Slides authored by Sabrina Nardin. AI used to polish slides style and fix typos.*
</span>

# 1. Using For Loops with Dataframes {.slide .center .middle}

---

## Same Task With and Without a For Loop

```{r echo = TRUE, results = "hide"}

library(tidyverse)
library(palmerpenguins)
data(penguins)
```

```{r}
glimpse(penguins)
```

<br>

#### Task: Calculate the mean value of several columns in this data

</br>

---

## Calculate the mean value of several columns *without a loop*

We can take the `mean()` function, and apply it to each column:

```{r echo = TRUE, results = "hide"}

penguins %>% summarize(avg_bill_length = mean(bill_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_bill_depth = mean(bill_depth_mm, na.rm = TRUE))
penguins %>% summarize(avg_flipper_length = mean(flipper_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_body_mass = mean(body_mass_g, na.rm = TRUE))
                       
```

<!--
```r
mean(penguins_clean$bill_length_mm)
mean(penguins_clean$bill_depth_mm)
mean(penguins_clean$flipper_length_mm)
mean(penguins_clean$body_mass_g)
```
-->

This works, but requires a lot of copy/paste! How can we do the same thing with a for loop?

---

## Automate the same task *with a loop*

First, initialize an empty vector to store the results. 

Second, use a for loop to calculate the mean of each (numeric) column of this penguins dataframe. 

Let's run this code:

```{r echo = TRUE, results = "hide"}

output <- vector(mode = "double", length = ncol(penguins))

for (i in seq_along(penguins)) {
  output[i] <- mean(penguins[[i]], na.rm = TRUE)
}

output
```

---

## Why output[i] and penguins[[i]]?

```{r echo = TRUE, results = "hide"}

output <- vector(mode = "double", length = ncol(penguins))

for (i in seq_along(penguins)) {
  output[i] <- mean(penguins[[i]], na.rm = TRUE)
}

output
```

::: {.callout}

**`output` is a vector where we store the loop results:**

- To access elements of a vector, use single square brackets `[]` 
- So `output[i]` assigns the computed value into the *i-th position* of that vector 

**`penguins` is a dataframe (or tibble):**

- But `mean()` needs a numeric vector  
- To access a dataframe column *as a vector*, use double brackets `[[]]`  
- So `penguins[[i]]` gets the *i-th column* of the dataframe, and turns it into a vector 

:::


---

## Why output[i] and penguins[[i]]?

```{r echo=TRUE, results="hide"}
is.vector(penguins[[3]])           # TRUE (the raw vector)
is.data.frame(penguins[3])         # TRUE (a 1-col tibble/data frame)

mean(penguins[[3]], na.rm = TRUE)  # works, correct type (vector)
mean(penguins[3], na.rm = TRUE)    # error, wrong type (1-col tibble)
```

<br>

::: callout 

**With data frames:** `[[ ]]` returns the column itself as a vector, while `[ ]` returns a one-column data frame or tibble

**With vectors:** `[]` and `[[ ]]` behave the same, but is good practice to consistently use `[]` when subsetting vectors 

*Review Lecture 10 and the Data Structures quiz for details.*

:::

</br>

---

## ðŸ’» Practice Subsetting Data frames 

### Answer these questions:

1. What does `is.vector(penguins[["bill_len"]])` return, and why are there quotation marks around the column name? And what does `penguins[["bill_len"]]` return? 

2. Write code to access the fourth column of the penguins dataset in four ways:

    - By column name, returned as a vector
    - By index, returned as a vector
    - By column name, returned as a dataframe
    - By index, returned as a dataframe

For each object, check its data structure using  `is.vector()` or `is.data.frame()` (which return true or false) or `str()` which provides an overview of the object. 

3. What does `is.vector(penguins[[1]])` return and why the output is not what we expect? What about `is.data.frame(penguins[1])`?

# 2. Alternatives to For Loops in R {.slide .center .middle}

---

## Why We Even Learn Loops in R?

R is a **vectorized language**, meaning it's able to apply operations to entire vectors in one go.

This also implies that many tasks in R can and should be done **without writing a for loop**.

Still, understanding loops is important:

- to build **logic and control flow** skills
- for **non-vectorized tasks**, like row-by-row operations
- to **debug** more complex workflows

<!--
> Even if you donâ€™t use loops every day, knowing how they work will strengthen your ability to write efficient and readable R code.
-->

---

## Three Main Alternatives to For Loops in R

When working with dataframes, R provides the following alternatives to for loop:

| Function Family        | Package     | Best Used For                                  | Docs |
|------------------------|-------------|------------------------------------------------|-------------|
| `map_*()`              | purrr     | Applying functions to elements of lists or columns | [map docs](https://purrr.tidyverse.org/reference/map.html) |
| `across()`             | dplyr     | Applying the same function to multiple columns inside `mutate()` or `summarize()` | [across docs](https://dplyr.tidyverse.org/reference/across.html) |
| `*apply()`             | base R      | Row/column-wise operations on matrices or data frames | [apply docs](https://stat.ethz.ch/R-manual/R-devel/library/base/html/apply.html) |

<br>

The asterisk `*` is a placeholder for a family of related functions (e.g., `map_dbl()`, `map_chr()`, `sapply()`, etc.)

</br>

<!--
1. `map_*()` functions from `purr` <https://purrr.tidyverse.org/reference/map.html>
2. `across()` function from `dplyr` <https://dplyr.tidyverse.org/reference/across.html>
3. `*apply()` functions from base R <https://stat.ethz.ch/R-manual/R-devel/library/base/html/apply.html>

The asterisk `*` is a placeholder indicating a *family* of related functions (e.g., `map_dbl()`, `map_chr()`, `sapply()`, etc.).

- Use the `map_*()` functions from the *purrr* package for flexible iteration  
- Use `across()` with `summarize()` or `mutate()` for column-wise operations  
- Use `apply()` to iterate over rows or columns in a matrix or data frame
-->

---

## Option 1: Replacing for loops with map() functions

<!-- As we have seen in the slides and practice, we have to write a lot of code for a for loop, for example to calculate a straightforward operation like the mean or median etc. so R gives us a shortcut: map functions which come from the purrr package in R and are much more compact (go to the documentation page)
-->

The so-called "map functions" come from the `purr` package in R: <https://purrr.tidyverse.org/reference/map.html>

**There are several `map_*()` functions**  each creates a different type of output (this is the same idea as in the `for loop` when we specify the `mode` of our output vector):

- `map()` makes a list
- `map_lgl()` makes a logical vector
- `map_int()` makes an integer vector
- `map_dbl()` makes a double vector
- `map_chr()` makes a character vector

Let's see a few examples using the `penguins` data.

---

## Option 1: Replacing for loops with map() functions

Pick the appropriate `map()` function (there are several!) and specify at least two main arguments:

- what you are iterating over
- what you are calculating

```{r echo = TRUE, results = "hide"}

penguins %>% 
  select(where(is.numeric)) %>%
  map_dbl(mean, na.rm = TRUE)

```

<!-- ADD PRACTICE EXERCISE
## ðŸ’» Practice
-->

---

## Option 2: Replacing for loops with across()

**Another option to replace a for loop is the `across()` function from `dplyr`**

**What it does:** applies the same operation (e.g., mean) to multiple columns at once  

**Best use:** since it comes from `dplyr`, it works seamlessly inside `dplyr` verbs like `mutate()` and `summarize()` which these are its favorite verbs to work with!

---

## Option 2: Replacing for loops with across()

We looked at this example earlier (which calculates the mean of several columns in a data frame) and we rewrote it using a for loop. 

```{r echo = TRUE, results = "hide"}

penguins %>% summarize(avg_bill_length = mean(bill_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_bill_depth = mean(bill_depth_mm, na.rm = TRUE))
penguins %>% summarize(avg_flipper_length = mean(flipper_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_body_mass = mean(body_mass_g, na.rm = TRUE))
                       
```

Now we rewrite it again but this time using `across()`

---

## Option 2: Replacing for loops with across()

Rewrite previous example using `across()`:

```{r echo = TRUE, results = "hide"}

penguins %>% 
  summarize(
    across(
      .cols = where(is.numeric),           # select columns by type
      .fns = ~ mean(.x, na.rm = TRUE)))    # apply mean, skipping NA
```

<br>

**The function `across()` has two main arguments:**

- **`.cols`**: the columns to operate on. You can select them by position, name, or type - in this example, by type using `where(is.numeric)`

- **`.fns`**: the function, or list of functions, to apply to each column (in this example, we use `mean()` and `.x` is a placeholder for the current column being processed)

You can omit `.cols` and `.fns` if you pass the arguments in the correct order.

</br>

---

## Option 2: Replacing for loops with across()

Add names to the newly computed means:

```{r echo = TRUE, results = "hide"}

penguins %>% 
  summarize(
    across(
      .cols = where(is.numeric),                   
      .fns = ~ mean(.x, na.rm = TRUE),             
      .names = "avg_{.col}"                   
    )
  )
```

<br>

**What does `\"avg_{.col}\"` mean?**

- `"avg_"` is a literal prefix that will be added to each new column name.  
- `{.col}` is a placeholder that will be replaced with the original column name.

So if you're applying `mean()` to a column named `bill_length_mm`, the result will be named `avg_bill_length_mm`

</br>

<!-- FOR CSS CLASS: ADD THOSE EXAMPLES OR MORE + A PRACTICE EXERCISE

## More examples using the [`worldbank` data](https://data.worldbank.org/)

```{r worldbank}
data("worldbank", package = "rcis")
worldbank
```

---

### `summarize()`, `across()`, and `where()`

```{r summarize-across-where}
# use across() with where() to pick variables based on type (e.g. is.numeric(), etc.)
worldbank %>% 
  group_by(country) %>%
  summarize(across(.cols = where(is.numeric), .fns = mean, na.rm = TRUE))
```

```{r summarize-across-compound}

# or pick variables based on type and whose name begins with "perc"
worldbank %>%
  group_by(country) %>%
  summarize(across(
    .cols = where(is.numeric) & starts_with("perc"),
    .fn = mean, na.rm = TRUE
  ))
```


---

### `across()` and `filter()`

To use `across()` with `filter()`, we need an extra step: `if_any()` or `if_all()`

```{r filter-if-any, echo = TRUE, results = "hide"}

# if_any() keeps rows where the predicate is true for at least one column
worldbank %>%
  filter(if_any(everything(), ~ !is.na(.x)))
```

```{r filter-if-all, echo = TRUE, results = "hide"}

# if_all() keeps rows where the predicate is true for all selected columns
worldbank %>%
  filter(if_all(everything(), ~ !is.na(.x)))
```

-->

---

## Option 3: Replacing for loops with apply() functions

**Finally, a third option to replace a for loop in R is using one of the `apply()` functions from base R**

**What it does:** applies the same operation (e.g., mean) to multiple columns at once  

**Best use:** when working outside tidyverse verbs (this is from base R!) and can be applied across rows or columns (most common)

---

## Option 3: Replacing for loops with apply() functions

We looked at this example earlier (which calculates the mean of several columns in a data frame) and rewrote it using a `for` loop. Now we rewrite it again but this time using `apply()`:

```{r echo = TRUE, results = "hide"}

penguins %>% summarize(avg_bill_length = mean(bill_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_bill_depth = mean(bill_depth_mm, na.rm = TRUE))
penguins %>% summarize(avg_flipper_length = mean(flipper_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_body_mass = mean(body_mass_g, na.rm = TRUE))
                       
```

---

## Option 3: Replacing for loops with apply() functions

Rewrite previous example using `apply()`:

```{r echo = TRUE, results = "hide"}

# manually select only numeric column using base R syntax
penguins_numeric <- penguins[ , c("bill_length_mm", "bill_depth_mm", 
                                  "flipper_length_mm", "body_mass_g")]

# apply mean to these columns
apply(penguins_numeric, 2, mean, na.rm = TRUE)  

```

Note the `2` stays for `MARGIN = 2` (apply on the columns). If you write 1 it means rows. 

Type `?apply` in your Console for more info.

---

## Option 3: Replacing for loops with apply() functions

The `apply()` family refers to several related functions you can use:

| Function   | Use Case                                          | Input Type                    | Output Type       | Why Use It                                      |
|------------|---------------------------------------------------|-------------------------------|-------------------|-------------------------------------------------|
| `apply()`  | Apply a function across **rows or columns**       | Matrix, data frame            | Vector or matrix  | For row/column-wise operations                  |
| `lapply()` | Apply a function to **each element**              | List, data frame              | List              | Keeps outputs as list (safe, flexible)          |
| `sapply()` | Like `lapply()` but **simplifies** output         | List, data frame              | Vector or matrix  | Shorter output, easier to read                  |
| `vapply()` | Like `sapply()`, but **requires output type**     | List, data frame              | Vector or matrix  | Safer than `sapply()` (explicit type checking)  |
| `tapply()` | Apply a function to **vector values by group**    | Vector + Factor(s)            | Vector            | For group-wise summaries (e.g., mean by sex) |

<br>

You donâ€™t need to memorize each one â€” but remember there are multiple apply() options. Look them up and pick the one that fits your task!

</br>

---

## Option 3: Replacing for loops with apply() functions

```{r echo = TRUE, results = "hide"}

# Use numeric columns from penguins dataset
num_data <- penguins[ , 3:6]

# apply(): function across columns (MARGIN = 2)
apply(num_data, 2, mean, na.rm = TRUE)

# lapply(): list output
lapply(num_data, mean, na.rm = TRUE)

# sapply(): simplified vector output
sapply(num_data, mean, na.rm = TRUE)

# vapply(): safe version of sapply()
vapply(num_data, mean, na.rm = TRUE, FUN.VALUE = numeric(1))

```

::: callout-tip

#### Tips for the `apply()` Family

- `apply()` works best with **matrix-like** structures  
- `lapply()` is **list-safe**, but `sapply()` is more **concise** 
- `vapply()` avoids surprises by **enforcing output type** (here returns a single numeric value)

:::


# 3. While Loops {.slide .center .middle}

---

## Definition of While Loops

We focused on "for loops" because they are the most common, but R, and many other programming languages, also supports "while loops"

**How while loops works:**

- Evaluate a condition
- If the condition is `TRUE`, run the loop body
- Start over: re-evaluate the condition
- Repeat until the condition is `FALSE` (then the while loop is over)

---

## While Loop Syntax

Syntax:
```
while (condition to be evaluated) {
  statement(s)
}
```

Example:
```r
counter <- 1

while(counter <= 4) {
  print(counter)
  counter <- counter + 1
}
```

<!-- 
set the counter outside the loop, usually to 1
set a condition to be evaluated: here the condition says the counter has to be smaller or equal to 4
if the condition is TRUE, the loop is executed, here we only print(counter)
thus the first time it prints 1
but if we leave it as it is (without the last line of code), the while loops will keep going infinitely: we need a way to break the loop
thus we increment our counter inside the loop by redefining it as counter + 1
-->
---

## While Loop Examples

Take the previous code, but this time print `counter` also at the end:

```r
counter <- 1

while(counter <= 3) {
  print(counter)
  counter <- counter + 1
  print(counter)
}
```

Why are the results different from the previous code?

---

## While Loop Examples

Take the previous code, but this time we do not increment our `counter` variable.

```r
counter <- 1
while(counter < 3){
  print(counter)
}
```

What is the output of this code?

---

## While Loop Examples

What is the output of this code?

```r
counter <- 1
while(counter < 4){
  print(counter)
  multiply <- counter * 100
  print(multiply)
  counter <- counter + 1
  print(counter)
}
```

---

## While Loop Uses

While Loops are useful **when you don't know in advance how many times to iterate** â€” you want the loop to continue **until a condition is met**.

#### Example use cases:

- Keep looping until you get **three heads in a row** from random coin flips  
- Keep accepting user input **until you reach a target number of responses**

While loops require a **"count variable"** to be set outside the loop.

While loops are important but less common than for loops especially for the types of tasks we do in this course. For this reason, we donâ€™t cover them in-depth.


# 4. Introduction to Functions {.slide .center .middle}

---

## From using to writing functions

Today we learn the following concepts:

- Using existing functions
- Writing your own function
- The return statement
- stop()

---

## Using existing functions

Functions are all over R! We have been **using functions** from day 1 of this course. For example:

```{r echo = TRUE, results = "hide"}
a <- c(1:5)
a

sum(a)
mean(a)
```

---

## What is a function?

A function: 

* is a block of code that accomplishes a task

* has a name that typically describes the task, like `sum()` or `mean()`

* takes one or more inputs (e.g., arguments), processes it, and returns one or more outputs

---

## Using existing functions

To **use** a function, we need to know its arguments. 

In the console, type `help()` with the function's name in parenthesis to learn more about a function behavior and its arguments:

```r
help(sum)
help(mean)
```
<!-- mean(c(100, 1, 2, 3, 4, 5, 100, trim = 0.1)) -->

Some functions come from base R, like `sum()` or `mean()`

Other functions belong to specific packages, like `summarize()` or `mutate()` 

---

## Writing custom functions

Other than **using** functions created by others, we can also **write our own functions!**

To do that we need the following:

* **name**: something that describes the task that the function performs
* **arguments (input)**: at least one data structure (e.g., vector, etc.)
* **body**: self-contained lines of code that manipulate the input, defining what the function does
* **return (output):** statement that returns the result of the function's calculations

Syntax:
```r
name <- function(arg1, arg2, ...) { 
    result <- body with code that does things using arg1, arg2, etc.
    return(result)
    }
```
<!--
Note: 
* we can assign the function to a named object like any other object
* typically the body is multiple lines with multiple intermediate variables
-->

---

## Writing custom functions

For example, rather than using the built-in `sum()` function, we could **write our own sum function** to calculate the sum of the elements of a numeric vector, like this:

```r
my_sum <- function(vector) {
  total <- 0
  for (i in seq_along(vector)) {
    total <- total + vector[i]
  }
  return(total)
}

x <- c(2,1,5,2)
my_sum(x)
```

Let's unpack this code in Workbench...

---

## Writing custom functions

**Tip!** Write and test the code outside a function to make sure it works, like this:
```{r, echo = TRUE, results = "hide"}
x <- c(2,1,5,2)

total <- 0  # start with zero, we'll add elements to this

for (i in seq_along(x)) {
  total <- total + x[i]  # add the i-th value of x to total
}

total
```

Then wrap it into a function and test again with different inputs:
```{r, echo = TRUE, results = "hide"}
my_sum <- function(vector) {
  total <- 0
  for (i in seq_along(vector)) {
    total <- total + vector[i]
  }
  return(total)
}

x <- c(2, 1, 5, 2)
my_sum(vector = x)

y <- c(4,4)
my_sum(y)
```



<!-- LET'S STOP A SECOND AN UNPACK THIS CODE! DO THIS ON WORKBENCH 
SEE code lecture13_functions.Rmd -->

---

## Writing custom functions

To use a function, we need to **call it** with specific values. 

Our custom function `my_sum()` takes one argument, `vector`. When we call the function, this will be a specific vector, such as `x`, `y`, etc. 

```r
x <- c(2,1,5,2)
my_sum(vector = x)

y <- c(4,3,7)
my_sum(y)
```

---

## Advantages of writing custom functions

We use the sum example to illustrate how user-written functions work, but typically if there is already a built-in function in R that does what you need, just use it!

**Instead write your own function when...**

* there is no a built-in function 

* you want to reduce repetitive code and chances for mistakes

* you want to reuse code

* you want organize code (e.g., one function imports the data, another cleans the data, etc.)

---

## Tips for writing functions: name

Use **unique names**:

* if your function name matches the name of an existing R function, your function will replace the existing function for your current session (e.g., write `my_sum`, do not re-write `sum`)
* unless there is a specific reason (e.g. learning purposes, etc.), do not create a new function like `my_sum()` when R already has a built-in `sum()` function you can use

Use **informative names**: 

* the name should suggest what the function does 
* it should be short
* avoid reserved words like `if`, `else`, `for`, `function`, etc. To see the full list of reserved words type `help(reserved)` in the Console

---

## Tips for writing functions: variables scope

Variables defined inside a function are **not available outside it.** Their scope lies within and is limited to the function itself. Check this out:

```r
my_sum <- function(vector) {
  total <- 0
  for (i in seq_along(vector)) {
    total <- total + vector[i]
  }
  return(total)
}

x <- c(2,1,5,2)
my_sum(x)
total
```

---

## The return statement(s)

If you do not write a `return` statement, your output will be the last statement in your code:

```r
my_sum <- function(vector) {
  total <- 0
  for (i in seq_along(vector)) {
    total <- total + vector[i]
  }
  total
}

x <- c(2,1,5,2)
my_sum(x)

```

This works, but it's bettre to use `return` statements for code clarity and readability. **Remember that any code after `return` will be ignored** Let's see an example...

---

## Write multiple return statements

Writing multiple return statements with `if-else`:

```r
check_number <- function(x) {
  if (x > 0) {
    return("positive")
    }
  else if (x < 0) {
    return("negative")
    }
  else {
    return("zero")
    }
}
check_number(1)
```

If x > 0, the function returns "positive" without evaluating rest of the body.

---

## Write one return statement with multiple outputs

Sometimes you want to return multiple objects and collect them into a list or a vector:

```r
my_sum <- function(vector) {
  total <- 0
  for (i in seq_along(vector)) {
    total <- total + vector[i]
  }
  return(list(total, i))
}

x <- c(2,1,5,2)
y <- my_sum(x)

```

Questions:

- Can we return a vector rather than list here? How? 
- Why a list would generally be a better choice when your function returns multiple objects?

<!-- stop here change to vector with c() and return different elements with y[1] and y[2] change back to list and return different elements again -->

---

## Using stop() when writing a function

Define a function `celsius_to_fahr()` that converts temperatures from Celsius to Fahrenheit using the formula `fahrenheit = (celsius * 9/5) + 32`

```r
celsius_to_fahr <- function(celsius) {
  fahr <- (celsius * 9/5) + 32
  return(fahr)
}

celsius_to_fahr(0)
celsius_to_fahr(-20)
```

---

## Using stop() when writing a function

To ensure this function works properly, the argument must be numeric. Otherwise, the conversion between the two temperature scales will not work.

Solution: use `if-else` to verify if the provided argument is numeric; if not, use `stop()` to raise an error and stop the function execution

```r
celsius_to_fahr <- function(celsius) {
  if (!is.numeric(celsius)) {
    stop("error: input must be a number, try again")
  } else {
    fahr <- (celsius * 9/5) + 32
    return(fahr) 
  }
}

celsius_to_fahr("zero")
```

Why using stop() and not print()? 

<!-- 
`stop():` interrupts the execution of the function and throw an error message when a condition is not met 

`print()`: doesnt stop the function execution just print the message
so the first enforces a condition that must be met for the function to execute, and prints a message (which is optional); the other is only a message
-->

---

## ðŸ’» Practice writing functions 

### Download today's class materials from the website. 

---

## To print these slides as pdf

Click on the icon bottom-right corner \> Tools \> PDF Export Mode \> Print as a Pdf
