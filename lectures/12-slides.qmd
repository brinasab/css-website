---
title: "Computing for the Social Sciences: Lecture 12"
subtitle: "Topics: Writing For Loops"
author: "Sabrina Nardin, Fall 2025"
format:
  revealjs:
    theme: simple
    slide-number: true
    incremental: false
    css: ../style/styles.css
    code-overflow: wrap
    highlight-style: github
    ratio: 16:9
    chalkboard: true
    toc: false
    center: true
---


# Agenda {.center}

::: {.agenda-list}
1. For Loops
2. Tracking and Saving For Loops Output
3. Looping Over Elements vs. Indexes
4. Using For Loops with Dataframes
:::

<span style="font-size: 0.8em; color: #666;">
*Slides last updated on **November 5, 2025**. Slides authored by Sabrina Nardin. AI used to polish slides style and fix typos.*
</span>

<!-- NOTES TO IMPROVE CURRENT LOOP SLIDES

Add a few slides that show the differences of looping over indexes or looping over elements and 
teach that concept form the slides; then leave the in-class demo code with the key and let students explore it in team and go around for questions. Total time 10 min slides and 10 go over code + 5 review

In the demo for loop: add code on data structure, e.g. show how to access columns of a df and their elements with the double and single square brackets 

Show difference of accessing single column in a df (that is a vector so use []) or elements of columns for which you need to use [[]]

When you teach for loops add the break and continue statements (currently not in slides!)

-->


# 1. For Loops {.slide .center .middle}

---

### What Are Control Structures?

Control structures let us write code that can:

- **Make decisions** â†’ with **conditional statements** like `if`, `if...else`, etc.

- **Repeat actions**  â†’ with **loops** like `for`, `while` (today's topic)

Conditional statements and loops (e.g., control structures) let our code responds dynamically to different situations.

Today we focus on loops, and specifically on "For loops"!

---

## Definition of For Loops

For loops let you repeat an action for each element of an object, usually a vector or list. Theyâ€™re a common way to iterate in many programming languages.

Syntax:
```r
for (item in sequence of items) {
  action to be repeated for each item   
}
```

Example:
```r
for (item in c(1,2,3)) {
  print(item)
}
```
What's the repeated action here? How many times? What's item? 

<!--
Let's break this code down:

- The repeated action here is simple: `print(item)`

- `item` is a placeholder: its value changes with each loop iteration

- the number of times the statement block repeats depends on the number of items in the sequence â€” in this example: three items, thus three times
-->

---

## Nested For Loops

For loops can be nested, so the outer loop controls how many times the entire inner loop runs from start to finish: 

```{r echo = TRUE, results = "hide"}

for (i in c(1,2,3)) {
  print(i)
  for (j in c("cat", "dog", "squirrel", "rabbit")) {
    print(j)
  }
}
```

What's going on here?

- The outer loop runs 3 times

- For each execution of the outer loop, the inner loop runs 4 times

<!--
for (i in c(1,2,3)) {
  print(i)
  for (j in c("cat", "dog", "squirrel", "rabbit")) {
    print(j)
     for (x in c(10:11))
        print(x)
  }
}
-->

# 2. Tracking and Saving For Loops Output {.slide .center .middle}

---

## Tracing Execution in a For Loop

Observe this code. What does it output in each run?

```{r echo = TRUE, results = "hide"}

for (i in c(1, 2, 3)) {
  print(i)
  print("Hello")
  my_sum <- 100 + i
  print(my_sum)
  print(paste("End of Loop", i))
}
```

<br>

::: {.fragment}

#### ðŸ’» Change the code and predict what happens:

- Add another `print(my_sum)` before the line `my_sum <- 100 + i`. *Clear the environment and run the code: What happens?*
- Remove that line, and add these two lines `my_sum <- my_sum + i` and `print(my_sum)` right after the last `print(my_sum)`. *Clear the environment and run the code: What happens?*

<!-- Learning goals, in order by bullet point:
- Accessing a variable before assignment
- Reassigning a value
- Using a variable in its own reassignment
- Explore
-->

:::

</br>


---

## Tracing Execution in a For Loop

This is similar to the previous code, BUT defines `my_sum` outside the loop and updates it inside with `my_sum <- my_sum + i`

Clear the environment and run the code:

```{r echo = TRUE, results = "hide"}

my_sum <- 0

for (i in c(1, 2, 3)) {
  print(i)
  print("Hello")
  my_sum <- my_sum + i
  print(my_sum)
  print(paste("End of Loop", i))
}

```

<br>

::: {.fragment}

#### ðŸ’» Change the code and predict what happens:

- Comment out `my_sum <- my_sum + i`. *Clear the environment and run the code: What happens?*
- Go back the original code, then move `my_sum <- 0` inside the loop after `print("Hello")`. *Clear the environment and run the code: What happens?*

:::

</br>

---

## Accumulating a Running Total 

Loops are very useful for accumulating a running total â€” for example, **when you are adding up scores, votes, or anything else one at a time, and tracking how the total grows with each loop**.

This is the same code as in the previous slide, but with more informative print statements to make each step easier to follow. Clear the environment and run the code:

```{r echo = TRUE, results = "hide"}

my_sum <- 0

for (i in c(1,2,3)) {
  print(paste("Current i is", i))
  print("Hello")
  my_sum <- my_sum + i
  print(paste("Current sum is", my_sum))
  print(paste("End of Loop", i))
}

my_sum
```

---

## Saving Results from a For Loop

Our previous code printed the updated sum value each time, but only saved the final value! Like this:

```{r echo = TRUE, results = "hide"}
my_sum <- 0

for (i in c(1,2,3)) {
  my_sum <- my_sum + i
  print(my_sum)
}

my_sum
```

To save all intermediate sum values, we need to store them in a vector (here `output`). Like this:

```{r echo = TRUE, results = "hide"}

my_sum <- 0
output <- vector(mode = "integer", length = 3)  # new!

for (i in c(1,2,3)) {
  my_sum <- my_sum + i
  print(my_sum)
  output[i] <- my_sum     # new!
}

output
```

---

## Saving Results from a For Loop

To save all intermediate sum values, we need to store them in a vector (here `output`). Like this:

```{r echo = TRUE, results = "hide"}

my_sum <- 0
output <- vector(mode = "integer", length = 3)  # new!

for (i in c(1,2,3)) {
  my_sum <- my_sum + i
  print(my_sum)
  output[i] <- my_sum     # new!
}

output

```

::: {.callout-note .fragment .small-text title="`output[i] <- my_sum`"}

When `i = 1`, `my_sum = 0 + 1 = 1` â†’ store `1` in `output[1]` â†’ output becomes: `1 0 0`  
When `i = 2`, `my_sum = 1 + 2 = 3` â†’ store `3` in `output[2]` â†’ output becomes: `1 3 0`  
When `i = 3`, `my_sum = 3 + 3 = 6` â†’ store `6` in `output[3]` â†’ output becomes: `1 3 6`

This saves the running total at each position `i` in the vector output!

:::

---

## Saving Results from a For Loop

**Our current code works but itâ€™s NOT YET optimal:**

- It only behaves correctly because the looping input vector is exactly `c(1, 2, 3)`
- If the values in that vector change, the current code may produce incorrect or unexpected results

**ðŸ’» Try this:** 

Take the code from the previous slide and change the looping input vector to `c(1, 4, 6)`. Clear the environment and run the code. Observe what happens to `output`. Why?

---

## Saving Results from a For Loop

```{r echo = TRUE, results = "hide"}
my_sum <- 0
output <- vector(mode = "integer", length = 3)

for (i in c(1,4,6)) {
  my_sum <- my_sum + i
  print(my_sum)
  output[i] <- my_sum 
}

output

```

::: {.callout-note .fragment .small title="What Happens in Each Iteration of this Loop"}

When `i = 1` â†’ `my_sum = 0 + 1 = 1` â†’ store `1` in `output[1]` â†’ output becomes: `1 0 0`

When `i = 4` â†’ `my_sum = 1 + 4 = 5` â†’ store `5` in `output[4]` â†’ output becomes: `1 0 0 5`

When `i = 6` â†’ `my_sum = 5 + 6 = 11` â†’ store 11 in `output[6]` â†’ output becomes: `1 0 0 5 NA 11`

**This does not look right! Why the output is not [1, 5, 11]?**   
To see why, we need to understand the difference between looping over elements vs. indexes...
:::

<!-- R wonâ€™t throw an error if you assign a value to an index beyond a vectorâ€™s original length: it silently extends the vector, which can lead to unexpected results.-->


# 3. Looping Over Elements vs. Indexes {.slide .center .middle}

---

## Elements vs. Indexes: Why It Matters

Run these examples and spot the differences:

```{r echo = TRUE, results = "hide"}

# Version A: Looping over values/elements
x <- c(1, 4, 6)
for (i in x) {
  print(i)        # value
}

# Version B: Looping over indexes
x <- c(1, 4, 6)
for (i in 1:length(x)) {
  print(i)        # index
  print(x[i])     # value at that index
}

# Same as Version B just another common method
x <- c(1, 4, 6)
for (i in seq_along(x)) {
  print(i)
  print(x[i])
}
```

::: {.callout-note .fragment .small title="`i` and `x[i]`"}

`i` is the loop **index** or "counter" and should always go 1, 2, 3, 4, etc.  
`x[i]` is the **element** or value of the vector `x` at position `i` and can be any value

:::

---

## Elements vs. Indexes: Why It Matters

Letâ€™s see what happens to our previous two codes when we save the output of them instead of just printing:

::: {.columns}

::: {.column width="50%"}

### âŒ Version A 

```{r echo = TRUE, results = "hide"}

x <- c(1, 4, 6)
my_sum <- 0
output <- vector(mode = "integer", 
                 length = length(x))

# looping over elements
for (i in x) {
  print(paste("Current i is:", i))
  my_sum <- my_sum + i
  print(paste("Current sum is:", my_sum))
  output[i] <- my_sum
}

output
```
:::

::: {.column width="50%"}

### âœ… Version B

```{r echo = TRUE, results = "hide"}

x <- c(1, 4, 6)
my_sum <- 0
output <- vector(mode = "integer", 
                 length = length(x))

# looping over indexes
for (i in seq_along(x)) {
  print(paste("Current i is:", i))
  my_sum <- my_sum + x[i]
  print(paste("Current sum is:", my_sum))
  output[i] <- my_sum
}

output

```
:::

::::


---

## Best Practice: Loop Over Indexes

Loop over indexes, like `i in 1:length(x)` or `seq_along(x)`, instead of elements/values. Advantages:

- You can modify, save, or assign values by position (e.g., `output[i] <- ...`)
- You ensure your loop works regardless of the values in the vector (e.g., if values repeat or are not valid indices)
- You have you full control over both: the position `i` and the value at that position `x[i]`

---

## ðŸ’» Practice: Fix the Bug in this For Loop

You are writing for loop to track `tomatoes` sold over three days. You want to add up the number of tomatoes sold and store the running total in the vector `output`. 

But something is wrong with the code â€” can you fix it? First, *predict* what the `output` vector should be, then *check* the code to find the bug.

```{r echo = TRUE, results = "hide"}

tomatoes <- c(10, 2, 100) 
s <- 0
output <- vector(mode = "integer", length = length(tomatoes))

for (i in seq_along(tomatoes)) {
  print(paste("Current i is:", i))
  s <- s + i
  print(paste("Current sum is:", s))
  output[i] <- s
}

output

```

<!--
```{r echo = TRUE, results = "hide"}

tomatoes <- c(10, 2, 100) 
s <- 0
output <- vector(mode = "integer", length = length(tomatoes))

for (i in seq_along(tomatoes)) {
  print(paste("Current i is:", i))
  s <- s + tomatoes[i]
  print(paste("Current sum is:", s))
  output[i] <- s
}

output

```
-->

<!--

## ðŸ’» Practice

You run a store and want to keep track of how many items were sold each day: you sold 5 items in day 1, 3 items on day 2, and 7 items on day 3

```r
daily_sales <- c(5, 3, 7)
```

Your Task:

- Use a for loop to go through each dayâ€™s sales 
- For each day, print something like: "Day 2 - Items sold: 3" (the message should change accordingly)
- Create an object called `total` to store a running total of all sales
- Create an object called `ouput` to store the total after each day (e.g. `output[2]` should store the total sales after day 2)

<!--
daily_sales <- c(5, 3, 7)

total <- 0
output <- vector(mode = "integer", length = length(daily_sales))

for (i in seq_along(daily_sales)) {
  print(paste("Day", i, "- Items sold:", daily_sales[i]))
  total <- total + daily_sales[i]
  output[i] <- total
}

-->

---

## Loops + Conditional Statements

This is code from our last lecture:
```{r, echo = TRUE, results = "hide"}
numbers <- c(10, 6, 7)
ifelse(numbers %% 2 == 1, 
       "odd",
       "even")
```

We can try to rewrite it using `if-else` statement, but we will get an error (recall why?):

```r
numbers <- c(10, 6, 7)
if (numbers %% 2 == 1) { 
  print("odd")
} else {
  print("even")
}
```

But now we know that we can fix it with a for loop!

```r
numbers <- c(10, 6, 7)
for (i in 1:length(numbers)) {
  if (numbers[i] %% 2 == 1) {
    print("odd")
  } else {
    print("even")
  }
}
```

# 4. Using For Loops with Dataframes {.slide .center .middle}

---

## Same Task With and Without a For Loop

```{r echo = TRUE, results = "hide"}

library(tidyverse)
library(palmerpenguins)
data(penguins)
```

```{r}
glimpse(penguins)
```

<br>

#### Task: Calculate the mean value of several columns in this data

</br>

---

## Calculate the mean value of several columns *without a loop*

We can take the `mean()` function, and apply it to each column:

```{r echo = TRUE, results = "hide"}

penguins %>% summarize(avg_bill_length = mean(bill_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_bill_depth = mean(bill_depth_mm, na.rm = TRUE))
penguins %>% summarize(avg_flipper_length = mean(flipper_length_mm, na.rm = TRUE))
penguins %>% summarize(avg_body_mass = mean(body_mass_g, na.rm = TRUE))
                       
```

<!--
```r
mean(penguins_clean$bill_length_mm)
mean(penguins_clean$bill_depth_mm)
mean(penguins_clean$flipper_length_mm)
mean(penguins_clean$body_mass_g)
```
-->

This works, but requires a lot of copy/paste! How can we do the same thing with a for loop?

---

## Automate the same task *with a loop*

First, initialize an empty vector to store the results. 

Second, use a for loop to calculate the mean of each (numeric) column of this penguins dataframe. 

Let's run this code:

```{r echo = TRUE, results = "hide"}

output <- vector(mode = "double", length = ncol(penguins))

for (i in seq_along(penguins)) {
  #print(i)
  #print(penguins[i])
  output[i] <- mean(penguins[[i]], na.rm = TRUE)
}

output
```

<!--

```r
output <- vector(mode = "double", length = ncol(penguins))

for (i in seq_along(penguins)) {
  if (is.numeric(penguins[[i]])) {
    output[i] <- mean(penguins[[i]], na.rm = TRUE)
  }
}

output
```
-->

<!-- 

### Let's unpack this example: open the **demo.Rmd** from today's class materials!

### Benefits of preallocation

This explains why we are pre-allocating in the first place, and why we do so with a vector:
having an object that is already of the same length of the output, where we are just plugging in  individual values increases speed, rather the more naive approach in which we store reuslts using an  mpty vector or an empty other object (e.g. a dataframe) of length zero, and then append or add on each of the values as we calculate them

For example, let's take this mpg data (built in dataframe in R about auto, we do not really care about the content of the data); here what we are doing is creating duplicates of that dataframe 100 times and we are then putting them together into a single data frame. 

Without preallocation: we can create an empty dataframe (here with the tibble function), iterate over 100 times, take this empty dataframe and combine the rows of it with the rows of the original dataframe, and replace the original object with the new copy and save in output (so we are appending 100 rows every time we iterate!) 

If we do proper preallocation: we create a list of 100 empty elements, every time we store the results in the list, then we use the bind_rows() functions at the end

The first approach does not preallocate by creating an empty space to store the output, the second does. See the difference in time of execution. From 80 milliseconds to less than 3. So you can see how inefficient is not to allocate since most of our data will have more than 100 rows!

.panelset[
.panel[.panel-name[Code]
```r
# no preallocation
mpg_no_preall <- tibble()
for(i in 1:100){
  mpg_no_preall <- bind_rows(mpg_no_preall, mpg)
}

# with preallocation using a list
mpg_preall <- vector(mode = "list", length = 100)
for(i in 1:100){
  mpg_preall[[i]] <- mpg
}
mpg_preall <- bind_rows(mpg_preall)
```
]

.panel[.panel-name[Plot]
```r
#| out.width = "70%",
#| echo = FALSE
# load microbenchmark library to time code
library(microbenchmark)
# bind together 100 copies of mpg
times <- microbenchmark(
  `No preallocation` = {
    mpg_no_preall <- tibble()
    
    for(i in 1:100){
      mpg_no_preall <- bind_rows(mpg_no_preall, mpg)
    }
  },
  `Preallocation` = {
    mpg_preall <- vector(mode = "list", length = 100)
    
    for(i in 1:100){
      mpg_preall[[i]] <- mpg
    }
    
    mpg_preall <- bind_rows(mpg_preall)
  }
)
autoplot(times)
```
]
]
-->


---

## Recap: What We Learned Today

- How for loops work and how to trace what happens at each iteration
- How to track and save values (like running totals) during a for loop
- Why it's important to loop over indexes instead of elements when saving or modifying values
- Common mistakes with loop output and how to fix them
- Combining if-else statements with for loops
- Using for Loops within a Dataframes (more on this next time!)

---

## To print these slides as pdf

Click on the icon bottom-right corner \> Tools \> PDF Export Mode \> Print as a Pdf
