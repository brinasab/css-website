---
title: "Computing for the Social Sciences: Lecture 8"
subtitle: "Topics: Exam 1 Overview, Intro to Tidydata, and to Lubridate"
author: "Sabrina Nardin, Fall 2025"
format:
  revealjs:
    theme: simple
    slide-number: true
    incremental: false
    css: ../style/styles.css
    code-overflow: wrap
    highlight-style: github
    ratio: 16:9
    chalkboard: true
    toc: false
    center: true
---

# Agenda {.center}

::: {.agenda-list}
1. Exam 1 Overview

2. Tidydata with Tidyr

3. Manipulating Dates with Lubridate  
:::

<!--
Time Management
1:30-1:55 Relational data (last time)
1:55-2:15 Exam 1 + 2 min survey (after quiz!) 
2:15-3:00 Tidydata
3:00-3:15 Dates with Lubridate
-->

<span style="font-size: 0.8em; color: #666;">
*Slides last updated on **October 22, 2025**. Slides authored by Sabrina Nardin. AI used to polish slides style and fix typos.*
</span>

```{r pkgs, include = FALSE, cache = FALSE}
library(tidyverse)
library(nycflights13)
library(rcis)
library(knitr)
#library(here)
```

# 1. Exam 1 Overview {.slide .center .middle}

---

## Exam Format

### Multiple-choice questions and short open-ended questions, such as:

- *Classical multiple choice* — select the correct answer from several options  
- *Spot the typo* — identify and fix syntax or logic errors  
- *Matching questions* — pair code snippets with their descriptions or outputs  
- *Debugging questions* — code runs but gives unexpected results; explain *why*  
- *Predict the output* — given a short R snippet determine what the code will return
- *Write code* — short applied tasks  
  - using `dplyr`: write small transformations (e.g., filter, summarize, group_by, mutate, etc.) on a provided tibble  
  - using `ggplot2`: write code to create simple graphs (see slides examples)
- *Open-ended questions* — brief written explanations or interpretations of results  

### Topics covered: Lectures 1-8 (inclusive)

### Make-up and absence policy: See Syllabus

---

## How to Prepare for the Exam

1. **Review class materials:** slides, in-class code, and assigned readings  

2. **Use Homework 1 and 2 as review practice** re-run your code and check you understand each step  

3. **Go through the in-class prep quizzes we have done** exam questions will be similar 

4. **Use AI strategically:** once you’ve done all the above, ask AI to generate additional practice questions of different types and level of difficulty. Starting with AI before reviewing materials usually backfires

::: {.callout-tip}
Preparation works best when you write and run code yourself, review your mistakes, and make sure you can explain *why* each answer is correct.
:::

# 2. Tidydata with Tidyr {.slide .center .middle}

--- 

## Tidy Data

### "Tidy data" is a particular way to organize data.

<br>

Useful because:

- **standardized:** every tidy dataset follows the same rules  
- **consistent:** tidy data can be used directly by many `tidyverse` packages without extra manipulation  
- **clear:** tidy data are easier to read, understand, and work with

---

## Tidy Data: Three Principles

```{r echo = FALSE, out.width = "70%", fig.alt = "Stylized text providing an overview of Tidy Data. The top reads 'Tidy data is a standard way of mapping the meaning of a dataset to its structure. - Hadley Wickham.' On the left reads 'In tidy data: each variable forms a column; each observation forms a row; each cell is a single measurement.' There is an example table on the lower right with columns ‘id’, ‘name’ and ‘color’ with observations for different cats, illustrating tidy data structure."}

include_graphics(path = "08-pics/tidydata_1.jpg")
```

::: {.footnote}
Illustrations from the blog [*Tidy Data for reproducibility, efficiency, and collaboration*](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by Julia Lowndes and Allison Horst
:::

<!-- 

tidy data is a very SPECIFICY way of standardizing info in a dataframe
but it is not the only way; we are going to see some examples
the opposite of tidy would be messy data or untidy 

the reason why tidy data is popular is because provides a STANDARDIZED form; all packages we have learned so far ggplot, dplyr work with tidy data which means you can simply load the dataset and start working on it without reshaping it or cleaning it up (if tidy)

-->

---

## Tidy Datasets Are All Alike

```{r echo = FALSE, out.width = "70%", fig.alt = "There are two sets of anthropomorphized data tables. The top group of three tables are all rectangular and smiling, with a shared speech bubble reading 'our columns are variables and our rows are observations!'. Text to the left of that group reads 'The standard structure of tidy data means that 'tidy datasets are all alike…' The lower group of four tables are all different shapes, look ragged and concerned, and have different speech bubbles reading (from left to right) 'my column are values and my rows are variables', 'I have variables in columns AND in rows', 'I have multiple variables in a single column', and 'I don’t even KNOW what my deal is.' Next to the frazzled data tables is text '...but every messy dataset is messy in its own way. -Hadley Wickham.'"}

include_graphics(path = "08-pics/tidydata_2.jpg")
```

::: {.footnote}
Illustrations from the blog [*Tidy Data for reproducibility, efficiency, and collaboration*](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by Julia Lowndes and Allison Horst
:::

<!-- pause think you are starting a research project and you have data as top or bottom; which one you want to be and why? -->

---

## Tidy Datasets Are All Alike

```{r echo = FALSE, out.width = "70%", fig.alt = "On the left is a happy cute fuzzy monster holding a rectangular data frame with a tool that fits the data frame shape. On the workbench behind the monster are other data frames of similar rectangular shape, and neatly arranged tools that also look like they would fit those data frames. The workbench looks uncluttered and tidy. The text above the tidy workbench reads 'When working with tidy data, we can use the same tools in similar ways for different datasets…' On the right is a cute monster looking very frustrated, using duct tape and other tools to haphazardly tie data tables together, each in a different way. The monster is in front of a messy, cluttered workbench. The text above the frustrated monster reads '...but working with untidy data often means reinventing the wheel with one-time approaches that are hard to iterate or reuse.'"}

include_graphics(path = "08-pics/tidydata_3.jpg")

```

::: {.footnote}
Illustrations from the blog [*Tidy Data for reproducibility, efficiency, and collaboration*](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by Julia Lowndes and Allison Horst
:::

---

## Tidying untidy data

::: {.callout-important}
It might sound counterintuitive, but **most real-world data isn't stored in a tidy format.**

**Why?**  
1. Many datasets are designed to make data entry, not analysis, easier  
2. Tidy data principles take time and practice to master
:::

<br>

::: {.callout-tip}
When working with the **tidyverse** (`ggplot2`, `dplyr`, etc.),  **start by putting your data in tidy format.**  Most tidyverse functions assume data are tidy!
:::

</br>

---

## Tidying Untidy Data

### OK, you are ready to start a project and loaded some data into R: they are untidy! 
### What should you do to tidy them up?


::: {.columns}
::: {.column width="50%"}
### First, Diagnose the data
- Identify the **variables** (what each column represents)
- Identify the **observations** (what each row represents)
- Spot **what’s untidy**  
  - Multiple variables in one column  
  - Variable values used as column names  
  - Variable names stored in rows
  - Etc.
:::

::: {.column width="40%"}
### Second, Fix it with tidyr
- Put **each variable** in its own **column**
- Put **each observation** in its own **row**
- Ensure **each cell** holds a **single value**

:::
:::

---

## Things You Can Do with the tidyr Package  

[Tidyr documentation](https://tidyr.tidyverse.org/)

* **Pivoting**  
  * `pivot_longer()` makes the dataset *longer* by increasing rows  
  * `pivot_wider()` makes the dataset *wider* by increasing columns  

* **Separating**  
  * `separate()` splits one column into multiple columns  

* **Uniting**  
  * `unite()` combines multiple columns into one  

::: {.callout-note}
The tidyr package includes many other functions, but we focus on the core ones for now. Each behaves a bit differently, so be sure to check the documentation for details on their arguments.
:::

---

##  Example

We’ll illustrate these tidying tasks using one of the datasets from the readings ([Chapter 5](https://r4ds.hadley.nz/data-tidy)). We are going to see different (untidy) ways to organize this dataset, and how to use `tidyr` to organize each of htem

The dataset is longitudinal, with four variables:  

- `country`  
- `year`  
- `cases` (number of tuberculosis cases)
- `population`

<!--
```{r}
library(tidyverse)
table1
```
-->

---

## Pivot Longer

Why is this dataset untidy? How can we tidy it?

```{r, echo = TRUE}
table4a
```

<br>

::: {.fragment}
- *"Each variable must have its own column"*: column names must be variables names, not variables values (here 1999 and 2000 are values of the year variable)
- *"Each observation must have its own row"*: here we have one row for every country, but this is panel data, so we should have the country-year pair to define one observation, not just country
:::

</br>

---

## Pivot Longer

<https://tidyr.tidyverse.org/reference/pivot_longer.html>

<br>

::: {.columns}
::: {.column width="45%"}
```{r spread-columns, echo = TRUE}
table4a
```
:::

::: {.column width="45%"}
```{r pivot-longer, echo = TRUE}
pivot_longer(data = table4a,
             cols = c(`1999`, `2000`),
             names_to = "year",
             values_to = "cases")
```
:::
:::

</br>

<!--
We can reshape and tidy this data using `pivot_longer` form tidyr, which takes four main arguments:
- data: data we are reshaping -- notice we go from a 3by3 to a 6by3 dataframe
- cols: name of the columns in the original data that we want to change -- aka columns to use to make this pivot; note the use of back ticks! and we need to use two columns, thus we use the vector syntax with c() for concatenate
- names_to column: new column we wish to create from column names
- values_to column: new column we wish to create and fill with values
-->

---

## Pivot Wider

Why is this dataset untidy? How can we tidy it?

```{r, echo = TRUE}
table2
```

<br>

::: {.fragment}
- *"Each variable must have its own column"*: the current values of `type` are not values, but are variables names 
- *"Each observation must have its own row"*: here an observation is a country in a year, which is correct, but each observation is spread across two rows due to how `type` is organanized
:::

</br>

---

## Pivot Wider

<https://tidyr.tidyverse.org/reference/pivot_wider.html>

<br>

::: {.columns}
::: {.column width="45%"}
```{r spread-rows, echo = TRUE}
table2
```
:::

::: {.column width="45%"}
```{r pivot-wider, echo = TRUE}
pivot_wider(data = table2,
            names_from = type,
            values_from = count)
```
:::
:::

</br>

---

## Separating

Why is this dataset untidy? How can we tidy it?

```{r echo = TRUE}
table3
```


---

## Separating

<https://tidyr.tidyverse.org/reference/separate.html>

<br>

::: {.columns}
::: {.column width="45%"}
```{r merged-columns, echo = TRUE}
table3
```
:::

::: {.column width="45%"}
```{r separate, echo = TRUE}
separate(data = table3,
         col = rate,
         into = c("cases","population"),
         convert = TRUE)
```
:::
:::

</br>

<!-- convert = TRUE bcs the default is FALSE
the original data are coded as chr but we want them as integer; if you do not convert it will leave them as chr
-->

---

## Uniting

Why is this dataset untidy? How can we tidy it?

```{r, echo = TRUE}
table5
```

---

## Uniting

<https://tidyr.tidyverse.org/reference/unite.html>

<br>

::: {.columns}
::: {.column width="45%"}
```{r merged-rows, echo = TRUE}
table5
```
:::

::: {.column width="45%"}
```{r unite, echo = TRUE}
unite(data = table5,
      col = "year", century, year)
```
:::
:::

<!-- Unite multiple columns into one by pasting strings together -->

</br>

---

## Uniting

::: {.columns}
::: {.column width="45%"}
```{r, echo = TRUE}
table5
```
:::

::: {.column width="45%"}
```{r unite-underscore, echo = TRUE}
unite(data = table5,
      col = "year", century, year,
      sep = "") # remove underscore
```
:::
:::

---

## Uniting

::: {.columns}
::: {.column width="45%"}
```{r, echo = TRUE}
table5
```
:::

::: {.column width="50%"}
```{r unite-parse, echo = TRUE}
unite(data = table5,
      col = "year", century, year,
      sep = "") |>
  mutate(year = as.integer(year)) # store as numeric
```
:::
:::

---

## Chain tidyr functions!  

::: {.columns}
::: {.column width="45%"}
```{r, echo = TRUE}
table5
```
:::

::: {.column width="50%"}
```{r, echo = TRUE}
unite(data = table5,
      col = "year", century, year,
      sep = "") |>
  mutate(year = as.integer(year)) |>
  separate(col = rate,
           into = c("cases", "population"),
           convert = TRUE)
```
:::
:::

<!--

# Let's get messy!

```{r echo = FALSE, out.width = "50%"}
include_graphics(path = "https://media.giphy.com/media/fCUCbWXe9JONVsJSUd/giphy.gif")
```
-->

---

## 💻 Practice Tidying Data

Download today's in-class exercises from the website.


# 3. Manipulating Dates with Lubridate {.slide .center .middle}

---

## Date and Times with Lubridate

Lubridate (also part of the `tidyverse`) is a handy package that makes it easier work with dates & times <https://r4ds.hadley.nz/datetimes.html>

::: {.fragment}

### Common Lubridate functions:

- Turn strings into dates or date-times with `ymd()`, `mdy()`, `dmy()`, `ymd_hms()`  
- Turn variables into dates or date-times with `make_datetime()`  
- Extract individual date components with `year()`, `month()`, `day()`, `wday()`  
- Round the date to a nearby unit of time `+ days(1)`, `floor_date()`, `round_date*()`  
- Handle time spans (multiple options, see Ch. 17)
- Handle time zones `with_tz()`, `force_tz()`  
:::

---

## Turn strings into dates or date-times

```{r, echo = TRUE}

ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
ymd_hms("2017-01-31 20:11:59")
```

---

## Turn variables into dates or date-times

::: {.columns}
::: {.column width="40%"}
```{r, echo = TRUE}
library(tidyverse)
library(nycflights13)
flights |> 
  select(year, month, day, hour, minute)
```
:::

::: {.column width="60%"}
```{r, echo = TRUE}
# create a date/time from this data with make_datetime()
flights |> 
  select(year, month, day, hour, minute) |> 
  mutate(departure = make_datetime(year, month, day, hour, minute))

```
:::
:::

<br>

More examples: <https://r4ds.hadley.nz/datetimes.html#from-individual-components>

</br>

---

## Extract individual date components 

```{r, echo = TRUE}
datetime <- ymd_hms("2025-10-22 12:30:33")

year(datetime)
month(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
```

More examples: <https://r4ds.hadley.nz/datetimes.html#getting-components>

---

##  Round the date to a nearby unit of time 

```{r, echo = TRUE}
# create date object from string
dt <- ymd_hms("2025-10-22 12:45:00")
dt

# round down with floor_date() 
floor_date(dt, "day")
floor_date(dt, "month")

# round up with ceiling_date()
ceiling_date(dt, "day")
ceiling_date(dt, "month")
```

More examples: <https://r4ds.hadley.nz/datetimes.html#rounding>

---

## Handle Time Spans

```{r, echo = TRUE}
# How old are you?
age <- today() - ymd("2001-10-22")
age

as.duration(age)
```

More examples: <https://r4ds.hadley.nz/datetimes.html#time-spans>

---

## Handle Time Zones

```{r, echo = TRUE}
greenwitch <- ymd_hms("2025-10-22 6:45:00")

# display same instant in another time zone
# shows local Central Time equivalent
with_tz(greenwitch, tzone = "America/Chicago")

# assign a time zone (without shifting actual clock time)
# interprets existing time as if it were recorded in Chicago
force_tz(greenwitch, "America/Chicago")
```

More examples: <https://r4ds.hadley.nz/datetimes.html#time-zones>

